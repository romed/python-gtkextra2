* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
/*
 * Python bindings for the GtkExtra widget set
 *
 * Copyright (C) 2000-2001 Andreas Voegele
 * Copyright (C) 2002 Toby D. Reeves
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

#define NO_IMPORT_PYGOBJECT
#include <pygobject.h>
#include <pygtk/pygtk.h>
#include <gtkextra/gtkextra.h>
#include <gtkextra/gtkextratypebuiltins.h>

static PyObject *pygtkextra_data_from_pyobject_callback = NULL;

/*
  This exists in pygtk/gtk/gtk-types.c.  It is not static there, but 
  is exported for our use.  Especially since dlopen is now not done
  with RTLD_GLOBAL flags by default. Might wish to ask James if it
  could be published or if there is another way.
*/

static gboolean
pygdk_rectangle_from_pyobject(PyObject *object, GdkRectangle *rectangle)
{
    g_return_val_if_fail(rectangle != NULL, FALSE);

    if (pyg_boxed_check(object, GDK_TYPE_RECTANGLE)) {
	*rectangle = *pyg_boxed_get(object, GdkRectangle);
	return TRUE;
    }
    if (PyArg_ParseTuple(object, "iiii", &rectangle->x, &rectangle->y,
			 &rectangle->width, &rectangle->height)) {
	return TRUE;
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError, "could not convert to GdkRectangle");
    return FALSE;
}

/* ----------------------------------------------------------------------
 Fixup boo-boo's or ommissions.  Probably should be fixed in gtkextra.
*/
#define GTK_ICON_FILE_SEL GTK_ICON_FILESEL
#define GTK_TYPE_ICON_FILE_SEL (gtk_icon_file_selection_get_type())
#define GTK_TYPE_COMBO_BOX (gtk_combobox_get_type())
#define GTK_TYPE_COLOR_COMBO (gtk_color_combo_get_type())
#define GTK_TYPE_BORDER_COMBO (gtk_border_combo_get_type())
#define GTK_TYPE_FONT_COMBO (gtk_font_combo_get_type())
#define GTK_TYPE_PLOT3_D (gtk_plot3d_get_type())
#define GTK_TYPE_TOGGLE_COMBO (gtk_toggle_combo_get_type())

/* Hack boxed types. Just enough to let code generator compile. Not correct!
   These and lots more need to be fixed in gtkextra code.
   A good example is GtkIconSet in gtkiconfactory.[hc].

   I wish 
     void gtk_plot_draw_text (GtkPlot *plot, GtkPlotText text);
   was instead
     void gtk_plot_draw_text (GtkPlot *plot, GtkPlotText *text);
   for all similiar functions.

 */

#define GTK_TYPE_PSFONT (gtk_psfont_get_type ())
static GType
gtk_psfont_get_type (void)
{
  static GType our_type = 0;
  
  if (our_type == 0)
    our_type = g_pointer_type_register_static ("GtkPSFont");

  return our_type;
}

#define GTK_TYPE_PLOT_TEXT (gtk_plot_text_get_type ())
static GType
gtk_plot_text_get_type (void)
{
  static GType our_type = 0;

#if 1 //HACK 
  if (our_type == 0)
    our_type = g_pointer_type_register_static ("GtkPlotText");
#else //Should be something similiar to this
  if (our_type == 0)
    our_type = g_boxed_type_register_static ("GtkPlotText",
					     (GBoxedCopyFunc) gtk_plot_text_ref,
					     (GBoxedFreeFunc) gtk_plot_text_unref);
#endif
  return our_type;
}

#define GTK_TYPE_PLOT_LINE (gtk_plot_line_get_type ())
static GType
gtk_plot_line_get_type (void)
{
  static GType our_type = 0;

#if 1 //HACK 
  if (our_type == 0)
    our_type = g_pointer_type_register_static ("GtkPlotLine");
#else //Should be something similiar to this
  if (our_type == 0)
    our_type = g_boxed_type_register_static ("GtkPlotLine",
					     (GBoxedCopyFunc) gtk_plot_line_ref,
					     (GBoxedFreeFunc) gtk_plot_line_unref);
#endif
  return our_type;
}

static void
gtk_plot_draw_text_PY (GtkPlot *plot, GtkPlotText *text)
{
    gtk_plot_draw_text(plot, *text); 
}

static void
gtk_plot_draw_line_PY (GtkPlot *plot, GtkPlotLine *line, gdouble x1, gdouble y1, gdouble x2, gdouble y2)
{
    gtk_plot_draw_line(plot, *line, x1, y1, x2, y2);
}

static void
gtk_plot_set_line_attributes_PY (GtkPlot *plot, GtkPlotLine *line)
{
    gtk_plot_set_line_attributes (plot, *line);
}

/* This one is probably an "error" in h2def.py */
#define GTK_PLOT3_D GTK_PLOT3D

guint16 gtk_plot_canvas_set_flags(GtkPlotCanvas *canvas, guint16 flags) { return GTK_PLOT_CANVAS_SET_FLAGS(canvas, flags); }
guint16 gtk_plot_canvas_unset_flags(GtkPlotCanvas *canvas, guint16 flags) { return GTK_PLOT_CANVAS_UNSET_FLAGS(canvas, flags); }

/* cpp abuse */
#define _GET_ONE_DOUBLE(_f, _c)  static PyObject * \
_wrap_##_f(PyGObject *self) \
{ \
    gdouble a; \
    _f(_c(self->obj), &a); \
    return Py_BuildValue("d", (double) a); \
}

#define _GET_TWO_DOUBLE(_f, _c)  static PyObject * \
_wrap_##_f(PyGObject *self) \
{ \
    gdouble a, b; \
    _f(_c(self->obj), &a, &b); \
    return Py_BuildValue("(dd)", (double) a, (double) b); \
}

int
pygtkextra_data_from_pyobject(PyObject **out_obj, PyObject *in_obj, gint *p_n, gdouble **p_points)
{
    *out_obj = NULL;
    *p_n = 0;
    *p_points = NULL;

    if ( !in_obj || (in_obj == Py_None )) {
	*out_obj = Py_None;
	Py_INCREF(Py_None);
	return 0;
    }

    /*
      Use the stored callback to convert into needed format.
    */
    PyObject *arglist, *result;
    if ( !pygtkextra_data_from_pyobject_callback ) {
	PyErr_SetString(PyExc_TypeError, "There is no data callback function registered.");
	return -1;
    }
    arglist = Py_BuildValue("(O)", in_obj);
    result = PyEval_CallObject(pygtkextra_data_from_pyobject_callback, arglist);
    Py_DECREF(arglist);

    if ( !result || !PyTuple_Check(result) || PyObject_Length(result) != 3) {
	PyErr_SetString(PyExc_TypeError, "callback must return (in_obj, buffer, buffer_len)");
	return -1;
    }
    
    *out_obj = PyTuple_GET_ITEM(result, 0);
    *p_points = (double*) PyLong_AsLong(PyTuple_GET_ITEM(result, 1));
    *p_n = PyInt_AsLong(PyTuple_GET_ITEM(result, 2));

    Py_INCREF(*out_obj); /* We now own a reference before tuple is destroyed. */
    Py_DECREF(result);
    return 0;
}

static int
pygtkextra_set_data(PyGObject *gobj, const char *key, PyObject *pobj)
{
    PyObject *result = PyObject_CallMethod( (PyObject*) gobj, "set_data", "(sO)", key, pobj);
    if ( !result )
	return -1;
    Py_DECREF(result); /* was Py_None */
    return 0;
}

static PyObject *
pygtkextra_get_data(PyGObject *gobj, const char *key)
{
    return PyObject_CallMethod( (PyObject*) gobj, "get_data", "(s)", key);
}

/*
 * pygtkextra_convert_pixmap_data_to_vector
 *
 * Takes a list of pixmap data strings and puts them into a C vector.
 * The vector must be freed by the caller.  If the pixmap data cannot
 * be converted the Python error indicator will be set and NULL will
 * be returned.
 */
char **
pygtkextra_convert_pixmap_data_to_vector(PyObject *data)
{
    int len, i;
    char **vector;

    if (!PySequence_Check(data)) {
	PyErr_SetString(PyExc_TypeError, "pixmap data must be a sequence");
	return NULL;
    }
    len = PySequence_Length(data);
    vector = g_new(char *, len);
    for (i = 0; i < len; ++i) {
	PyObject *string;

	string = PySequence_GetItem(data, i);
	if (!PyString_Check(string)) {
	    PyErr_SetString(PyExc_TypeError, "sequence items must be strings");
	    g_free(vector);
	    Py_DECREF(string);
	    return NULL;
	}
	vector[i] = PyString_AS_STRING(string);
	Py_DECREF(string);
    }
    return vector;
}

/* ---------------------------------------------------------------------- */
%%
modulename gtkextra
%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixmap as PyGdkPixmap_Type
import gtk.gdk.Drawable as PyGdkDrawable_Type
import gtk.gdk.Rectangle as PyGdkRectangle_Type
import gtk._gtk.Widget as PyGtkWidget_Type
import gtk._gtk.Object as PyGtkObject_Type
import gtk._gtk.Container as PyGtkContainer_Type
import gtk._gtk.Fixed as PyGtkFixed_Type
import gtk._gtk.Toolbar as PyGtkToolbar_Type
import gtk._gtk.Entry as PyGtkEntry_Type
import gtk._gtk.Window as PyGtkWindow_Type
import gtk._gtk.CTree as PyGtkCTree_Type
import gtk._gtk.ToggleButton as PyGtkToggleButton_Type
import gtk._gtk.Adjustment as PyGtkAdjustment_Type
import gtk._gtk.HBox as PyGtkHBox_Type
%%
override gtk_psfont_get_char_size
static PyObject *
_wrap_gtk_psfont_get_char_size(PyObject *self)
{
    PyErr_SetString(PyExc_NotImplementedError, __FUNCTION__ );
    return NULL;
}
%%
override-attr GtkPlotCanvasChild.data
static PyObject *
_wrap_gtk_plot_canvas_child__get_data(PyObject *self, void *closure)
{
    switch (pyg_boxed_get(self, GtkPlotCanvasChild)->type) {
    case GTK_PLOT_CANVAS_NONE:
	Py_INCREF(Py_None);
	return Py_None;

    case GTK_PLOT_CANVAS_TEXT:
#if 0 // When boxed correctly
	return pyg_boxed_new(GTK_TYPE_PLOT_TEXT, pyg_boxed_get(self, GtkPlotCanvasChild)->data, TRUE, TRUE);
#else // Might also be ok when boxed correctly.
	return pyg_boxed_new(GTK_TYPE_PLOT_TEXT, pyg_boxed_get(self, GtkPlotCanvasChild)->data, FALSE, FALSE);
#endif
    case GTK_PLOT_CANVAS_PLOT:
    case GTK_PLOT_CANVAS_DATA:
    case GTK_PLOT_CANVAS_LEGENDS:
    default:
	return PyCObject_FromVoidPtr(pyg_pointer_get(self, GtkPlotCanvasChild)->data, NULL);
    }
}
%%
override gtk_plot_data_set_points kwargs
static PyObject *
_wrap_gtk_plot_data_set_points(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    /*
      Treat kwargs as a complete data set.
      If a key is specified set value.
      If a key is not specified clear value.
    */

    static char *kwlist[] = { "x", "dx", "y", "dy", "z", "dz", "a", "da", NULL };
    gdouble *x = NULL, *y = NULL, *dx = NULL, *dy = NULL, *z = NULL, *dz = NULL, *a = NULL, *da = NULL;
    PyObject *py_x = NULL, *py_y = NULL, *py_z = NULL, *py_a = NULL;
    PyObject *py_dx = NULL, *py_dy = NULL, *py_dz = NULL,  *py_da = NULL;

    PyObject *py_x_out = NULL, *py_y_out = NULL, *py_z_out = NULL, *py_a_out = NULL;
    PyObject *py_dx_out = NULL, *py_dy_out = NULL, *py_dz_out = NULL,  *py_da_out = NULL;

    int nx, ndx, ny, ndy, nz, ndz, na, nda;
    int rx, rdx, ry, rdy, rz, rdz, ra, rda;
    gint num_points=0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOOOOOOO:GtkPlotData.set_points", kwlist,
				     &py_x, &py_dx, &py_y, &py_dy, &py_z, &py_dz, &py_a, &py_da ))
        return NULL;

    rx = pygtkextra_data_from_pyobject( &py_x_out, py_x, &nx, &x);
    ry = pygtkextra_data_from_pyobject( &py_y_out, py_y, &ny, &y );
    rz = pygtkextra_data_from_pyobject( &py_z_out, py_z, &nz, &z );
    ra = pygtkextra_data_from_pyobject( &py_a_out, py_a, &na, &a );
    rdx = pygtkextra_data_from_pyobject( &py_dx_out, py_dx, &ndx, &dx );
    rdy = pygtkextra_data_from_pyobject( &py_dy_out, py_dy, &ndy, &dy );
    rdz = pygtkextra_data_from_pyobject( &py_dz_out, py_dz, &ndz, &dz );
    rda = pygtkextra_data_from_pyobject( &py_da_out, py_da, &nda, &da );

#if defined(_DEBUG)
    printf("n: %d %d %d %d %d %d %d %d\n", nx, ny, ndx, ndy, nz, ndz, na, nda);
    printf("r: %d %d %d %d %d %d %d %d\n", rx, ry, rdx, rdy, rz, rdz, ra, rda);
#endif

    if ( (rx < 0) || (ry < 0) || (rdx < 0) || (rdy < 0) 
	 || (rz < 0) || (rdz < 0) || (rda < 0) || (rda < 0) ) {
	goto do_err;
    }
	
    num_points = MAX(nx, ndx);
    num_points = MAX(num_points, ny);
    num_points = MAX(num_points, ndy);
    num_points = MAX(num_points, nz);
    num_points = MAX(num_points, ndz);
    num_points = MAX(num_points, na);
    num_points = MAX(num_points, nda);

#if defined(_DEBUG)
    printf("num+_points = %d\n", num_points);
#endif

    if ( (rx && (nx != num_points))
	 || (rdx && (ndx != num_points))
	 || (ry && (ny != num_points))
	 || (rdy && (ndy != num_points))
	 || (rz && (nz != num_points))
	 || (rdz && (ndz != num_points))
	 || (ra && (na != num_points))
	 || (rda && (nda != num_points)) ) {
	PyErr_SetString(PyExc_TypeError, "argments must have same length");
	goto do_err;
    }

    gtk_plot_data_set_numpoints(GTK_PLOT_DATA(self->obj), num_points);

#define _DO_ONE(_x) \
    if ( pygtkextra_set_data(self, #_x, py_ ## _x ## _out) ) \
	goto do_err; \
    Py_DECREF(py_ ## _x ##_out);  \
    gtk_plot_data_set_ ## _x  (GTK_PLOT_DATA(self->obj), _x); \
    
    _DO_ONE(x);
    _DO_ONE(dx);
    _DO_ONE(y);
    _DO_ONE(dy);
    _DO_ONE(z);
    _DO_ONE(dz);
    _DO_ONE(a);
    _DO_ONE(da);

#undef _DO_ONE

    Py_INCREF(Py_None);
    return Py_None;

 do_err:
    Py_XDECREF(py_x_out);
    Py_XDECREF(py_dx_out);
    Py_XDECREF(py_y_out);
    Py_XDECREF(py_dy_out);
    Py_XDECREF(py_z_out);
    Py_XDECREF(py_dz_out);
    Py_XDECREF(py_a_out);
    Py_XDECREF(py_da_out);
    return NULL;
}
%%
override-attr GtkPlotData.x
static PyObject *
_wrap_gtk_plot_data__get_x(PyGObject *self, void *closure)
{
    return pygtkextra_get_data(self, "x");
}
%%
override-attr GtkPlotData.dx
static PyObject *
_wrap_gtk_plot_data__get_dx(PyGObject *self, void *closure)
{
    return pygtkextra_get_data(self, "dx");
}
%%
override-attr GtkPlotData.y
static PyObject *
_wrap_gtk_plot_data__get_y(PyGObject *self, void *closure)
{
    return pygtkextra_get_data(self, "y");
}
%%
override-attr GtkPlotData.dy
static PyObject *
_wrap_gtk_plot_data__get_dy(PyGObject *self, void *closure)
{
    return pygtkextra_get_data(self, "dy");
}
%%
override-attr GtkPlotData.z
static PyObject *
_wrap_gtk_plot_data__get_z(PyGObject *self, void *closure)
{
    return pygtkextra_get_data(self, "z");
}
%%
override-attr GtkPlotData.dz
static PyObject *
_wrap_gtk_plot_data__get_dz(PyGObject *self, void *closure)
{
    return pygtkextra_get_data(self, "dz");
}
%%
override-attr GtkPlotData.a
static PyObject *
_wrap_gtk_plot_data__get_a(PyGObject *self, void *closure)
{
    return pygtkextra_get_data(self, "a");
}
%%
override-attr GtkPlotData.da
static PyObject *
_wrap_gtk_plot_data__get_da(PyGObject *self, void *closure)
{
    return pygtkextra_get_data(self, "da");
}
%%
ignore
  gtk_plot_data_get_points
  gtk_plot_data_get_x
  gtk_plot_data_get_dx
  gtk_plot_data_get_y
  gtk_plot_data_get_dy
  gtk_plot_data_get_z
  gtk_plot_data_get_dz
  gtk_plot_data_get_a
  gtk_plot_data_get_da
  gtk_plot_data_set_x
  gtk_plot_data_set_dx
  gtk_plot_data_set_y
  gtk_plot_data_set_dy
  gtk_plot_data_set_z
  gtk_plot_data_set_dz
  gtk_plot_data_set_a
  gtk_plot_data_set_da
%%
override gtk_plot_canvas_get_active_point noargs
static PyObject *
_wrap_gtk_plot_canvas_get_active_point(PyGObject *self)
{
    gint active_point;
    gdouble x, y;

    active_point = gtk_plot_canvas_get_active_point(GTK_PLOT_CANVAS(self->obj), &x, &y);
    return Py_BuildValue("(idd)", (int) active_point, (double) x, (double) y);
}
%%
override gtk_color_combo_find_color
static PyObject *
_wrap_gtk_color_combo_find_color(PyGObject *self, PyObject *args)
{
    int row, col;
    GdkColor *color = NULL;
    PyObject *py_color = NULL;
    if (!PyArg_ParseTuple(args, "O", &py_color)) {
	return NULL;
    }
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor");
        return NULL;
    }
    gtk_color_combo_find_color(GTK_COLOR_COMBO(self->obj), pyg_boxed_get(py_color, GdkColor), &row, &col);
    return Py_BuildValue("(ii)", row, col);
}
%%
override gtk_plot_canvas_get_pixel
static PyObject *
_wrap_gtk_plot_canvas_get_pixel(PyGObject *self, PyObject *args)
{
    double px, py;
    int x, y;
    if (!PyArg_ParseTuple(args, "dd", &px, &py)) {
	return NULL;
    }
    gtk_plot_canvas_get_pixel(GTK_PLOT_CANVAS(self->obj), px, py, &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_plot_canvas_get_position
static PyObject *
_wrap_gtk_plot_canvas_get_position(PyGObject *self, PyObject *args)
{
    int x, y;
    gdouble px, py;
    if (!PyArg_ParseTuple(args, "ii", &x, &y)) {
	return NULL;
    }
    gtk_plot_canvas_get_position(GTK_PLOT_CANVAS(self->obj), x, y, &px, &py);
    return Py_BuildValue("(dd)", px, py);
}
%%
override gtk_plot_get_internal_allocation noargs
static PyObject *
_wrap_gtk_plot_get_internal_allocation(PyGObject *self)
{
    GtkAllocation allocation;
    allocation = gtk_plot_get_internal_allocation(GTK_PLOT(self->obj));
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &allocation, TRUE, TRUE);
}
%%
override gtk_plot_add_data kwargs
static PyObject *
_wrap_gtk_plot_add_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "data", NULL };
    PyGObject *data;
    char key[1024];

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkPlot.add_data", kwlist, &PyGtkPlotData_Type, &data))
        return NULL;
    gtk_plot_add_data(GTK_PLOT(self->obj), GTK_PLOT_DATA(data->obj));
    g_snprintf(key, sizeof(key), "data_%p", data);
    pygtkextra_set_data(self, key, (PyObject*) data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_plot_remove_data kwargs
static PyObject *
_wrap_gtk_plot_remove_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "data", NULL };
    PyGObject *data;
    int ret;
    char key[1024];

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkPlot.remove_data", kwlist, &PyGtkPlotData_Type, &data))
        return NULL;
    ret = gtk_plot_remove_data(GTK_PLOT(self->obj), GTK_PLOT_DATA(data->obj));
    g_snprintf(key, sizeof(key), "data_%p", data);
    pygtkextra_set_data(self, key, Py_None); /* not perfect, but harmless */
    return PyInt_FromLong(ret);
}
%%
override gtk_plot_get_pixel
static PyObject *
_wrap_gtk_plot_get_pixel(PyGObject *self, PyObject *args)
{
    double xx, yy;
    double x, y;
    if (!PyArg_ParseTuple(args, "dd", &xx, &yy)) {
	return NULL;
    }
    gtk_plot_get_pixel(GTK_PLOT(self->obj), xx, yy, &x, &y);
    return Py_BuildValue("(dd)", x, y);
}
%%
override gtk_plot_get_point
static PyObject *
_wrap_gtk_plot_get_point(PyGObject *self, PyObject *args)
{
    int x, y;
    double xx, yy;
    if (!PyArg_ParseTuple(args, "ii", &x, &y)) {
	return NULL;
    }
    gtk_plot_get_point(GTK_PLOT(self->obj), x, y, &xx, &yy);
    return Py_BuildValue("(dd)", xx, yy);
}
%%
override gtk_plot_get_xrange noargs
_GET_TWO_DOUBLE(gtk_plot_get_xrange, GTK_PLOT)
%%
override gtk_plot_get_yrange noargs
_GET_TWO_DOUBLE(gtk_plot_get_yrange, GTK_PLOT)
%%
override gtk_plot_get_position noargs
_GET_TWO_DOUBLE(gtk_plot_get_position, GTK_PLOT)
%%
override gtk_plot_get_size noargs
_GET_TWO_DOUBLE(gtk_plot_get_size, GTK_PLOT)
%%
override gtk_plot_axis_get_attributes kwargs
static PyObject *
_wrap_gtk_plot_axis_get_attributes(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "axis", NULL };
    PyObject *py_axis = NULL;
    gfloat width;
    GdkColor color = {0, };
    GtkPlotAxisPos axis;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkPlot.axis_get_attributes", kwlist, &py_axis))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PLOT_AXIS_POS, py_axis, (gint *)&axis))
        return NULL;
    gtk_plot_axis_get_attributes(GTK_PLOT(self->obj), axis, &width, &color);
    return Py_BuildValue("(dO)", (double)width, pyg_boxed_new(GDK_TYPE_COLOR, &color, TRUE, TRUE));
}
%%
override gtk_plot_grids_visible noargs
static PyObject *
_wrap_gtk_plot_grids_visible(PyGObject *self)
{
    gboolean vmajor, vminor, hmajor, hminor;
    gtk_plot_grids_visible(GTK_PLOT(self->obj), &vmajor, &vminor, &hmajor, &hminor);
    return Py_BuildValue("(iiii)", (int) vmajor, (int) vminor, (int) hmajor, (int) hminor);
}
%%
override gtk_plot_legends_get_position noargs
_GET_TWO_DOUBLE(gtk_plot_legends_get_position, GTK_PLOT)
%%
override gtk_plot_legends_get_allocation noargs
static PyObject *
_wrap_gtk_plot_legends_get_allocation(PyGObject *self)
{
    GtkAllocation allocation;
    allocation = gtk_plot_legends_get_allocation(GTK_PLOT(self->obj));
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &allocation, TRUE, TRUE);
}
%%
override _set_data_from_pyobject_callback
static PyObject *
_wrap__set_data_from_pyobject_callback(PyObject *dummy, PyObject *args)
{

    PyObject *cb;

    if (!PyArg_ParseTuple(args, "O", &cb)) {
	return NULL;
    }

    if (cb == Py_None) {
	if ( pygtkextra_data_from_pyobject_callback != NULL ) {
	    Py_DECREF(pygtkextra_data_from_pyobject_callback);
	}
	pygtkextra_data_from_pyobject_callback = NULL;
    }
    else {
	Py_INCREF(cb);
	pygtkextra_data_from_pyobject_callback = cb;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore-glob *_get_type
